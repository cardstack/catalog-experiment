{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "recipes": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/definitions/recipe"
      },
      "title": "Recipes",
      "description": "A list of recipes to apply to this package organized by the semver range for which the recipe applies.",
      "additionalItems": false
    },
    "recipe": {
      "type": "object",
      "required": [
        "semverRange"
      ],
      "properties": {
        "semverRange": {
          "type": "string",
          "title": "Semver Range",
          "description": "A range of package versions for which the recipe applies. Refer to https://github.com/npm/node-semver#ranges for how to construct semver ranges."
        },
        "srcRepo": {
          "$ref": "#/definitions/srcRepo",
          "title": "Source Repository",
          "description": "By default we will perform the build from the js located in the resolved node_modules package folder. When srcRepo is set to true we will use the package.json \"repository\" property to locate the source for the package. Otherwise, we'll utilize the properties in the srcRepo object to locate the source repository for this package."
        },
        "entrypoints": {
          "$ref": "#/definitions/entrypoints",
          "title": "Entrypoints",
          "description": "By default we'll use the package.json \"main\" property for the pkg entrypoints. If there is no \"main\" property, then we'll try \"./index.js\". Otherwise this can be set/overridden by the \"entrypoints\" property. Note that we are not using the \"browser\" property in the package.json because typically all the ES modules are compiled out of the browser module."
        },
        "srcIncludeGlob": {
          "type": "string",
          "title": "Source Include Glob",
          "description": "This is a glob that describes all the files to include in the javascript build from the package. By default this is \"**/*.{js,json}\", and can be overridden using the \"srcIncludeGlob\" property."
        },
        "srcIgnoreGlob": {
          "type": "string",
          "title": "Source Ignore Glob",
          "description": "This is a glob that describes all the files to ignore in the javascript build from the package. By default this is \"{node_modules,test}/**\", and can be overridden using the \"srcIgnoreGlob\" property."
        },
        "babelPlugins": {
          "$ref": "#/definitions/babelPlugins",
          "title": "Babel Plugins",
          "description": "By default the optional chaining and nullish coalescing operator plugins will be used when performing the build, as well as we'll continue to add other plugins for late stage TC39 proposals that are on the verge of becoming part of the spec. To utilize additional babel plugins, specify those in the \"babelPlugins\" property"
        },
        "resolutions": {
          "$ref": "#/definitions/resolutions",
          "title": "Resolutions",
          "description": "If you wish to override the resolver and provide a specific resolution, then use the \"resolution\" property. This is an object whose keys are specifier strings that appear in the import statements you wish to resolve yourself. The values are the catalogjs URLs to modules you would like the specifier to resolve to. For instance, in order to add a resolution for the builtin node module \"assert\" to leverage the catalogjs assert polyfill you can specify:\n \"assert\": \"https://catalogjs.com/pkgs/@catalogjs/polyfills/assert.js\""
        }
      },
      "additionalProperties": false
    },
    "srcRepo": {
      "type": [
        "object",
        "boolean"
      ],
      "properties": {
        "repoHref": {
          "type": "string",
          "format": "uri",
          "title": "Repo HREF",
          "description": "By default we'll use the package.json \"repository\" property for the pkg source. Otherwise it can be specified here."
        },
        "version": {
          "type": "string",
          "title": "Version",
          "description": "By default we'll use the package.json \"version\" property to checkout the package source from git. This can be overridden with a specific branch/tag/SHA by setting the version property. The version string supports semver replacement tags, \"$major$\", \"$minor$\", and \"$patch$\". So if you want to checkout a tag that that simply has a prefix or suffix added to the version, you can use replacements tags. For instance if the current version of the package is \"3.12.4\", and you want to check out tag \"3.12.4_es\", you can specify:\n  $major$.$minor$.$patch$_es\nor to prefix a \"v\" in front of the version (which is a common practice):\n  v$major$.$minor$.$patch$",
          "default": "v$major$.$minor$.$patch$"
        },
        "subdir": {
          "type": "string",
          "title": "Subdirectory",
          "description": "When the repo is actually a mono repo, the package is located in a subdirectory of the repository. By default this will attempted to be derived from the package.json \"repository\" property by using the part of the repository path that appears after the ../tree/branch_name/ part of the path. This can be overridden by setting the subdir property."
        }
      },
      "additionalProperties": false
    },
    "entrypoints": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "string"
      },
      "additionalItems": false
    },
    "babelPlugins": {
      "type": "array",
      "minItems": 1
    },
    "resolutions": {
      "type": "object",
      "minItems": 1,
      "additionalProperties": {
        "type": "string"
      }
    }
  },
  "type": "object",
  "additionalItems": false,
  "properties": {
    "$schema": {
      "type": "string",
      "format": "uri-reference"
    },
    "recipes": {
      "$ref": "#/definitions/recipes"
    }
  }
}